// Advanced Export and Sharing Utilities
import { TokenizationResult } from '@/lib/tokenizer';
import { DetailedTokenizationResult, DetailedTokenInfo, TokenAnalytics } from '@/lib/advanced-tokenizer';
import { EncodingResult, CharacterAnalysis, TextStatistics } from '@/lib/encodings';

export interface ExportData {
  timestamp: string;
  textSample: string;
  tokenization: TokenizationResult[];
  detailedAnalysis?: {
    tokenInfo: DetailedTokenInfo[];
    analytics: TokenAnalytics;
  };
  encodings?: EncodingResult[];
  statistics?: TextStatistics;
  metadata: {
    version: string;
    userAgent: string;
    exportFormat: string;
  };
}

export interface ShareableReport {
  id: string;
  title: string;
  description: string;
  data: ExportData;
  settings: {
    showCosts: boolean;
    showTokens: boolean;
    showEncodings: boolean;
    theme: 'light' | 'dark';
  };
}

// Export formats
export function exportToCSV(data: TokenizationResult[], filename: string = 'tokenization-analysis'): void {
  const headers = [
    'Model',
    'Provider', 
    'Token Count',
    'Characters',
    'Words',
    'Input Cost ($)',
    'Output Cost ($)',
    'Total Cost ($)',
    'Processing Time (ms)',
    'Efficiency (chars/token)'
  ];
  
  const rows = data.map(result => [
    result.modelId,
    getProviderByModelId(result.modelId),
    result.tokenCount,
    result.characterCount,
    result.wordsCount,
    result.inputCost.toFixed(6),
    result.outputCost.toFixed(6),
    (result.inputCost + result.outputCost).toFixed(6),
    result.processingTime.toFixed(2),
    (result.characterCount / result.tokenCount).toFixed(2)
  ]);
  
  const csvContent = [headers, ...rows]
    .map(row => row.map(field => `"${field}"`).join(','))
    .join('\n');
    
  downloadFile(csvContent, `${filename}.csv`, 'text/csv');
}

export function exportToJSON(exportData: ExportData, filename: string = 'text-analysis'): void {
  const jsonContent = JSON.stringify(exportData, null, 2);
  downloadFile(jsonContent, `${filename}.json`, 'application/json');
}

export function exportToMarkdown(data: TokenizationResult[], textSample: string, filename: string = 'analysis-report'): void {
  const timestamp = new Date().toISOString();
  const samplePreview = textSample.length > 100 ? textSample.substring(0, 100) + '...' : textSample;
  
  let markdown = `# Text Analysis Report\n\n`;
  markdown += `**Generated:** ${timestamp}\n`;
  markdown += `**Text Sample:** "${samplePreview}"\n`;
  markdown += `**Character Count:** ${textSample.length}\n`;
  markdown += `**Models Analyzed:** ${data.length}\n\n`;
  
  // Summary table
  markdown += `## Model Comparison\n\n`;
  markdown += `| Model | Provider | Tokens | Characters | Input Cost | Output Cost | Total Cost | Efficiency |\n`;
  markdown += `|-------|----------|--------|------------|------------|-------------|------------|------------|\n`;
  
  data.forEach(result => {
    const provider = getProviderByModelId(result.modelId);
    const efficiency = (result.characterCount / result.tokenCount).toFixed(2);
    const totalCost = (result.inputCost + result.outputCost).toFixed(6);
    
    markdown += `| ${result.modelId} | ${provider} | ${result.tokenCount} | ${result.characterCount} | $${result.inputCost.toFixed(6)} | $${result.outputCost.toFixed(6)} | $${totalCost} | ${efficiency} |\n`;
  });
  
  // Cost analysis
  const sortedByCost = [...data].sort((a, b) => (a.inputCost + a.outputCost) - (b.inputCost + b.outputCost));
  const cheapest = sortedByCost[0];
  const mostExpensive = sortedByCost[sortedByCost.length - 1];
  
  markdown += `\n## Cost Analysis\n\n`;
  markdown += `**Most Affordable:** ${cheapest.modelId} - $${(cheapest.inputCost + cheapest.outputCost).toFixed(6)}\n`;
  markdown += `**Most Expensive:** ${mostExpensive.modelId} - $${(mostExpensive.inputCost + mostExpensive.outputCost).toFixed(6)}\n`;
  markdown += `**Cost Range:** ${((mostExpensive.inputCost + mostExpensive.outputCost) / (cheapest.inputCost + cheapest.outputCost)).toFixed(2)}x\n\n`;
  
  // Token efficiency
  const sortedByTokens = [...data].sort((a, b) => a.tokenCount - b.tokenCount);
  const mostEfficient = sortedByTokens[0];
  const leastEfficient = sortedByTokens[sortedByTokens.length - 1];
  
  markdown += `## Token Efficiency\n\n`;
  markdown += `**Most Efficient:** ${mostEfficient.modelId} - ${mostEfficient.tokenCount} tokens\n`;
  markdown += `**Least Efficient:** ${leastEfficient.modelId} - ${leastEfficient.tokenCount} tokens\n`;
  markdown += `**Token Range:** ${(leastEfficient.tokenCount / mostEfficient.tokenCount).toFixed(2)}x\n\n`;
  
  markdown += `---\n*Generated by TextAnalyzer - Professional AI Text Analysis Platform*`;
  
  downloadFile(markdown, `${filename}.md`, 'text/markdown');
}

export function exportToPDF(data: TokenizationResult[], textSample: string, filename: string = 'analysis-report'): void {
  // For now, we'll create an HTML version that can be printed to PDF
  const htmlContent = generateHTMLReport(data, textSample);
  
  // Create a new window with the content for printing
  const printWindow = window.open('', '_blank');
  if (printWindow) {
    printWindow.document.write(htmlContent);
    printWindow.document.close();
    printWindow.onload = () => {
      printWindow.print();
    };
  }
}

function generateHTMLReport(data: TokenizationResult[], textSample: string): string {
  const timestamp = new Date().toISOString();
  const samplePreview = textSample.length > 200 ? textSample.substring(0, 200) + '...' : textSample;
  
  return `
    <!DOCTYPE html>
    <html>
    <head>
        <title>Text Analysis Report</title>
        <style>
            body { font-family: system-ui, -apple-system, sans-serif; margin: 2rem; color: #1a1a1a; }
            .header { border-bottom: 2px solid #e5e7eb; padding-bottom: 1rem; margin-bottom: 2rem; }
            .title { font-size: 2rem; font-weight: bold; margin-bottom: 0.5rem; }
            .meta { color: #6b7280; font-size: 0.875rem; }
            .section { margin-bottom: 2rem; }
            .section-title { font-size: 1.25rem; font-weight: semibold; margin-bottom: 1rem; border-bottom: 1px solid #e5e7eb; padding-bottom: 0.5rem; }
            table { width: 100%; border-collapse: collapse; margin-bottom: 1rem; }
            th, td { padding: 0.5rem; text-align: left; border-bottom: 1px solid #e5e7eb; }
            th { background-color: #f9fafb; font-weight: semibold; }
            .highlight { background-color: #fef3c7; padding: 0.25rem 0.5rem; border-radius: 0.25rem; }
            .footer { margin-top: 3rem; padding-top: 1rem; border-top: 1px solid #e5e7eb; color: #6b7280; font-size: 0.875rem; }
            @media print { body { margin: 1rem; } }
        </style>
    </head>
    <body>
        <div class="header">
            <div class="title">Text Analysis Report</div>
            <div class="meta">
                Generated: ${new Date(timestamp).toLocaleString()}<br>
                Characters: ${textSample.length} | Models: ${data.length}<br>
                Sample: "${samplePreview}"
            </div>
        </div>
        
        <div class="section">
            <div class="section-title">Model Comparison</div>
            <table>
                <thead>
                    <tr>
                        <th>Model</th>
                        <th>Provider</th>
                        <th>Tokens</th>
                        <th>Input Cost</th>
                        <th>Output Cost</th>
                        <th>Total Cost</th>
                        <th>Efficiency</th>
                    </tr>
                </thead>
                <tbody>
                    ${data.map(result => {
                      const provider = getProviderByModelId(result.modelId);
                      const efficiency = (result.characterCount / result.tokenCount).toFixed(2);
                      const totalCost = (result.inputCost + result.outputCost).toFixed(6);
                      
                      return `
                        <tr>
                            <td>${result.modelId}</td>
                            <td>${provider}</td>
                            <td>${result.tokenCount}</td>
                            <td>$${result.inputCost.toFixed(6)}</td>
                            <td>$${result.outputCost.toFixed(6)}</td>
                            <td><strong>$${totalCost}</strong></td>
                            <td>${efficiency} c/t</td>
                        </tr>
                      `;
                    }).join('')}
                </tbody>
            </table>
        </div>
        
        <div class="section">
            <div class="section-title">Key Insights</div>
            ${generateInsights(data)}
        </div>
        
        <div class="footer">
            Generated by TextAnalyzer - Professional AI Text Analysis Platform
        </div>
    </body>
    </html>
  `;
}

function generateInsights(data: TokenizationResult[]): string {
  const sortedByCost = [...data].sort((a, b) => (a.inputCost + a.outputCost) - (b.inputCost + b.outputCost));
  const sortedByTokens = [...data].sort((a, b) => a.tokenCount - b.tokenCount);
  
  const cheapest = sortedByCost[0];
  const mostExpensive = sortedByCost[sortedByCost.length - 1];
  const mostEfficient = sortedByTokens[0];
  const leastEfficient = sortedByTokens[sortedByTokens.length - 1];
  
  return `
    <p><span class="highlight">Most Affordable:</span> ${cheapest.modelId} at $${(cheapest.inputCost + cheapest.outputCost).toFixed(6)} total cost</p>
    <p><span class="highlight">Most Expensive:</span> ${mostExpensive.modelId} at $${(mostExpensive.inputCost + mostExpensive.outputCost).toFixed(6)} total cost</p>
    <p><span class="highlight">Most Token Efficient:</span> ${mostEfficient.modelId} with ${mostEfficient.tokenCount} tokens</p>
    <p><span class="highlight">Cost Variance:</span> ${((mostExpensive.inputCost + mostExpensive.outputCost) / (cheapest.inputCost + cheapest.outputCost)).toFixed(2)}x difference between cheapest and most expensive</p>
    <p><span class="highlight">Token Variance:</span> ${(leastEfficient.tokenCount / mostEfficient.tokenCount).toFixed(2)}x difference in token counts</p>
  `;
}

// Sharing functionality
export function generateShareableLink(data: ExportData): string {
  // In a real implementation, this would upload to a service and return a shareable URL
  const encodedData = btoa(JSON.stringify(data));
  const baseUrl = window.location.origin;
  return `${baseUrl}/share/${encodedData.substring(0, 10)}`;
}

export function copyToClipboard(content: string): Promise<void> {
  return navigator.clipboard.writeText(content);
}

export function shareViaWebAPI(data: ExportData): void {
  if (navigator.share) {
    const shareData = {
      title: 'Text Analysis Results',
      text: `Analysis of ${data.textSample.length} characters across ${data.tokenization.length} AI models`,
      url: generateShareableLink(data)
    };
    
    navigator.share(shareData).catch(err => {
      console.error('Error sharing:', err);
      // Fallback to clipboard
      copyToClipboard(JSON.stringify(data, null, 2));
    });
  } else {
    // Fallback for browsers without Web Share API
    copyToClipboard(generateShareableLink(data));
  }
}

// Utility functions
function downloadFile(content: string, filename: string, mimeType: string): void {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function getProviderByModelId(modelId: string): string {
  // This should be imported from your AI_MODELS, but for now we'll use heuristics
  if (modelId.includes('gpt') || modelId.includes('openai')) return 'OpenAI';
  if (modelId.includes('claude')) return 'Anthropic';
  if (modelId.includes('gemini')) return 'Google';
  if (modelId.includes('llama')) return 'Meta';
  if (modelId.includes('mistral')) return 'Mistral';
  if (modelId.includes('command')) return 'Cohere';
  return 'Unknown';
}

// Template generators
export function generateComparisonTemplate(data: TokenizationResult[]): string {
  return `
# AI Model Tokenization Comparison

## Quick Summary
- **Models Analyzed**: ${data.length}
- **Best Value**: ${data.reduce((best, current) => (current.inputCost + current.outputCost) < (best.inputCost + best.outputCost) ? current : best).modelId}
- **Most Efficient**: ${data.reduce((best, current) => current.tokenCount < best.tokenCount ? current : best).modelId}

## Detailed Results
${data.map(result => `
### ${result.modelId}
- Tokens: ${result.tokenCount}
- Total Cost: $${(result.inputCost + result.outputCost).toFixed(6)}
- Efficiency: ${(result.characterCount / result.tokenCount).toFixed(2)} chars/token
`).join('')}
  `;
}

export function generateCostBreakdownTemplate(data: TokenizationResult[]): string {
  const totalInputCost = data.reduce((sum, r) => sum + r.inputCost, 0);
  const totalOutputCost = data.reduce((sum, r) => sum + r.outputCost, 0);
  
  return `
# Cost Breakdown Analysis

## Overall Costs
- **Total Input Cost**: $${totalInputCost.toFixed(6)}
- **Total Output Cost**: $${totalOutputCost.toFixed(6)}
- **Combined Total**: $${(totalInputCost + totalOutputCost).toFixed(6)}

## Per-Model Breakdown
${data.map(result => `
**${result.modelId}**
- Input: $${result.inputCost.toFixed(6)}
- Output: $${result.outputCost.toFixed(6)}
- Total: $${(result.inputCost + result.outputCost).toFixed(6)}
`).join('')}
  `;
}